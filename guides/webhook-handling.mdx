---
title: "Webhook Handling Guide"
description: "Complete guide to handling braix webhooks securely and reliably"
---

# Webhook Handling Guide

Webhooks are essential for real-time payment processing. This guide covers everything you need to know about handling braix webhooks securely and reliably.

## What are Webhooks?

Webhooks are HTTP callbacks that braix sends to your application when specific events occur, such as payment completions, failures, or refunds. They allow you to receive real-time notifications without polling the API.

## Webhook Security

### Checksum Verification

All braix webhooks include a `checksum` field for verification. Always verify the checksum to ensure the webhook is authentic:

<CodeGroup>
```javascript Node.js
const crypto = require('crypto');

const verifyChecksum = (data, receivedChecksum, secret) => {
  // O checksum é calculado com base nos dados da transação original
  // Deve ser o mesmo checksum retornado na requisição de geração do QR Code ou Payment
  const expectedChecksum = crypto
    .createHash('sha256')
    .update(JSON.stringify(data))
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(receivedChecksum),
    Buffer.from(expectedChecksum)
  );
};

// In your webhook handler
app.post('/webhooks/braix', (req, res) => {
  const { data } = req.body;
  const receivedChecksum = data.checksum;
  
  if (!verifyChecksum(data, receivedChecksum, process.env.WEBHOOK_SECRET)) {
    return res.status(401).json({ error: 'Invalid checksum' });
  }
  
  // Process webhook safely
  res.status(200).json({ received: true });
});
```

```python Python
import hashlib
import hmac

def verify_checksum(data, received_checksum, secret):
    # O checksum é calculado com base nos dados da transação original
    expected_checksum = hashlib.sha256(
        json.dumps(data, sort_keys=True).encode()
    ).hexdigest()
    
    return hmac.compare_digest(received_checksum, expected_checksum)

# In your webhook handler
@app.route('/webhooks/braix', methods=['POST'])
def handle_webhook():
    data = request.get_json()
    received_checksum = data.get('data', {}).get('checksum')
    
    if not verify_checksum(data.get('data', {}), received_checksum, os.getenv('WEBHOOK_SECRET')):
        return jsonify({'error': 'Invalid checksum'}), 401
    
    # Process webhook safely
    return jsonify({'received': True})
```

```php PHP
<?php
function verifyChecksum($data, $receivedChecksum, $secret) {
    $expectedChecksum = hash('sha256', json_encode($data));
    return hash_equals($receivedChecksum, $expectedChecksum);
}

// In your webhook handler
$data = json_decode(file_get_contents('php://input'), true);
$receivedChecksum = $data['data']['checksum'] ?? '';

if (!verifyChecksum($data['data'], $receivedChecksum, $_ENV['WEBHOOK_SECRET'])) {
    http_response_code(401);
    echo json_encode(['error' => 'Invalid checksum']);
    exit;
}

// Process webhook safely
http_response_code(200);
echo json_encode(['received' => true]);
?>
```
</CodeGroup>

<Warning>
Never process webhooks without checksum verification. This is a critical security requirement.
</Warning>

## Webhook Events

braix sends webhooks for the following events:

<CardGroup cols={2}>
<Card title="RECEIVE" icon="arrow-down" href="/guides/webhooks/receive">
  **Pagamento PIX recebido e liquidado**
  - Depósito confirmado
  - Valor creditado na conta
  - Transação finalizada
</Card>

<Card title="TRANSFER" icon="arrow-up" href="/guides/webhooks/transfer">
  **Saque PIX confirmado e liquidado**
  - Saque processado com sucesso
  - Valor debitado da conta
  - Transação finalizada
</Card>

<Card title="CASHOUT" icon="x" href="/guides/webhooks/cashout">
  **Saque PIX rejeitado ou cancelado**
  - Saque rejeitado pelo banco
  - Transação cancelada
  - Valor não debitado
</Card>

<Card title="REFUND" icon="refresh-cw" href="/guides/webhooks/refund">
  **Transação estornada**
  - Estorno de depósito ou saque
  - Valor revertido
  - Transação cancelada
</Card>

<Card title="INFRACTION" icon="alert-triangle" href="/guides/webhooks/infraction">
  **Infração PIX reportada ou finalizada**
  - Contestação de transação
  - Análise de fraude
  - Resultado da contestação
</Card>
</CardGroup>

### Estrutura do Payload

Todos os webhooks seguem uma estrutura consistente:

```json
{
  "type": "TIPO_DO_WEBHOOK",
  "data": {
    // Dados específicos do evento
    "checksum": "hash_checksum"
  }
}
```

### Campos Comuns

<ParamField body="type" type="string">
  Tipo do webhook (RECEIVE, TRANSFER, CASHOUT, REFUND, INFRACTION)
</ParamField>

<ParamField body="data" type="object">
  Dados específicos do evento
</ParamField>

<ParamField body="data.checksum" type="string">
  Hash de verificação da transação (quando disponível)
</ParamField>

## Webhook Implementation

### Basic Webhook Handler

<CodeGroup>
```javascript Node.js
const express = require('express');
const app = express();

app.use(express.json());

app.post('/webhooks/braix', (req, res) => {
  const { type, data } = req.body;
  
  try {
    switch (type) {
      case 'RECEIVE':
        handleReceive(data);
        break;
        
      case 'TRANSFER':
        handleTransfer(data);
        break;
        
      case 'CASHOUT':
        handleCashout(data);
        break;
        
      case 'REFUND':
        handleRefund(data);
        break;
        
      case 'INFRACTION':
        handleInfraction(data);
        break;
        
      default:
        console.log('Unknown webhook type:', type);
    }
    
    res.status(200).json({ received: true });
  } catch (error) {
    console.error('Webhook processing error:', error);
    res.status(500).json({ error: 'Processing failed' });
  }
});

function handleReceive(data) {
  console.log('Payment received:', data);
  // Update database, send confirmation email, etc.
}

function handleTransfer(data) {
  console.log('Transfer completed:', data);
  // Handle successful withdrawal
}

function handleCashout(data) {
  console.log('Transfer rejected:', data);
  // Handle rejected withdrawal
}

function handleRefund(data) {
  console.log('Refund processed:', data);
  // Handle refund
}

function handleInfraction(data) {
  console.log('Infraction reported:', data);
  // Handle infraction
}

app.listen(3000, () => {
  console.log('Webhook server running on port 3000');
});
```

```python Python
from flask import Flask, request, jsonify
import json

app = Flask(__name__)

@app.route('/webhooks/braix', methods=['POST'])
def handle_webhook():
    data = request.get_json()
    webhook_type = data.get('type')
    
    try:
        if webhook_type == 'RECEIVE':
            handle_receive(data.get('data'))
        elif webhook_type == 'TRANSFER':
            handle_transfer(data.get('data'))
        elif webhook_type == 'CASHOUT':
            handle_cashout(data.get('data'))
        elif webhook_type == 'REFUND':
            handle_refund(data.get('data'))
        elif webhook_type == 'INFRACTION':
            handle_infraction(data.get('data'))
        else:
            print(f'Unknown webhook type: {webhook_type}')
        
        return jsonify({'received': True})
    except Exception as e:
        print(f'Webhook processing error: {e}')
        return jsonify({'error': 'Processing failed'}), 500

def handle_receive(data):
    print(f'Payment received: {data}')
    # Update database, send confirmation email, etc.

def handle_transfer(data):
    print(f'Transfer completed: {data}')
    # Handle successful withdrawal

def handle_cashout(data):
    print(f'Transfer rejected: {data}')
    # Handle rejected withdrawal

def handle_refund(data):
    print(f'Refund processed: {data}')
    # Handle refund

def handle_infraction(data):
    print(f'Infraction reported: {data}')
    # Handle infraction

if __name__ == '__main__':
    app.run(port=3000)
```

```php PHP
<?php
// webhook.php
$input = file_get_contents('php://input');
$data = json_decode($input, true);

$webhookType = $data['type'] ?? '';

try {
    switch ($webhookType) {
        case 'RECEIVE':
            handleReceive($data['data']);
            break;
            
        case 'TRANSFER':
            handleTransfer($data['data']);
            break;
            
        case 'CASHOUT':
            handleCashout($data['data']);
            break;
            
        case 'REFUND':
            handleRefund($data['data']);
            break;
            
        case 'INFRACTION':
            handleInfraction($data['data']);
            break;
            
        default:
            error_log('Unknown webhook type: ' . $webhookType);
    }
    
    http_response_code(200);
    echo json_encode(['received' => true]);
} catch (Exception $e) {
    error_log('Webhook processing error: ' . $e->getMessage());
    http_response_code(500);
    echo json_encode(['error' => 'Processing failed']);
}

function handleReceive($data) {
    error_log('Payment received: ' . json_encode($data));
    // Update database, send confirmation email, etc.
}

function handleTransfer($data) {
    error_log('Transfer completed: ' . json_encode($data));
    // Handle successful withdrawal
}

function handleCashout($data) {
    error_log('Transfer rejected: ' . json_encode($data));
    // Handle rejected withdrawal
}

function handleRefund($data) {
    error_log('Refund processed: ' . json_encode($data));
    // Handle refund
}

function handleInfraction($data) {
    error_log('Infraction reported: ' . json_encode($data));
    // Handle infraction
}
?>
```
</CodeGroup>

### Advanced Webhook Handler with Idempotency

<CodeGroup>
```javascript Node.js
const express = require('express');
const { v4: uuidv4 } = require('uuid');
const app = express();

// Store processed webhook IDs (use Redis in production)
const processedWebhooks = new Set();

app.use(express.json());

app.post('/webhooks/braix', async (req, res) => {
  const { type, data } = req.body;
  
  // Use transaction ID for idempotency
  const webhookId = data.id || data.txId || data.refundId;
  
  // Check for duplicate webhooks
  if (processedWebhooks.has(webhookId)) {
    return res.status(200).json({ received: true, duplicate: true });
  }
  
  try {
    // Process webhook
    await processWebhook(type, data);
    
    // Mark as processed
    processedWebhooks.add(webhookId);
    
    res.status(200).json({ received: true });
  } catch (error) {
    console.error('Webhook processing error:', error);
    res.status(500).json({ error: 'Processing failed' });
  }
});

async function processWebhook(type, data) {
  switch (type) {
    case 'RECEIVE':
      await handleReceive(data);
      break;
    case 'TRANSFER':
      await handleTransfer(data);
      break;
    case 'CASHOUT':
      await handleCashout(data);
      break;
    case 'REFUND':
      await handleRefund(data);
      break;
    case 'INFRACTION':
      await handleInfraction(data);
      break;
    default:
      console.log(`Unknown webhook type: ${type}`);
  }
}
```

```python Python
from flask import Flask, request, jsonify
import redis
import json

app = Flask(__name__)
redis_client = redis.Redis(host='localhost', port=6379, db=0)

@app.route('/webhooks/braix', methods=['POST'])
def handle_webhook():
    data = request.get_json()
    webhook_type = data.get('type')
    webhook_data = data.get('data', {})
    
    # Use transaction ID for idempotency
    webhook_id = webhook_data.get('id') or webhook_data.get('txId') or webhook_data.get('refundId')
    
    # Check for duplicate webhooks
    if redis_client.get(f'webhook:{webhook_id}'):
        return jsonify({'received': True, 'duplicate': True})
    
    try:
        # Process webhook
        process_webhook(webhook_type, webhook_data)
        
        # Mark as processed (expires in 24 hours)
        redis_client.setex(f'webhook:{webhook_id}', 86400, 'processed')
        
        return jsonify({'received': True})
    except Exception as e:
        print(f'Webhook processing error: {e}')
        return jsonify({'error': 'Processing failed'}), 500

def process_webhook(webhook_type, data):
    if webhook_type == 'RECEIVE':
        handle_receive(data)
    elif webhook_type == 'TRANSFER':
        handle_transfer(data)
    elif webhook_type == 'CASHOUT':
        handle_cashout(data)
    elif webhook_type == 'REFUND':
        handle_refund(data)
    elif webhook_type == 'INFRACTION':
        handle_infraction(data)
    else:
        print(f'Unknown webhook type: {webhook_type}')
```

```php PHP
<?php
// webhook.php
$input = file_get_contents('php://input');
$data = json_decode($input, true);

// Use transaction ID for idempotency
$webhookData = $data['data'] ?? [];
$webhookId = $webhookData['id'] ?? $webhookData['txId'] ?? $webhookData['refundId'] ?? '';

// Check for duplicate webhooks (use Redis in production)
$redis = new Redis();
$redis->connect('localhost', 6379);

if ($redis->get("webhook:{$webhookId}")) {
    http_response_code(200);
    echo json_encode(['received' => true, 'duplicate' => true]);
    exit;
}

try {
    // Process webhook
    processWebhook($data['type'], $webhookData);
    
    // Mark as processed (expires in 24 hours)
    $redis->setex("webhook:{$webhookId}", 86400, 'processed');
    
    http_response_code(200);
    echo json_encode(['received' => true]);
} catch (Exception $e) {
    error_log('Webhook processing error: ' . $e->getMessage());
    http_response_code(500);
    echo json_encode(['error' => 'Processing failed']);
}

function processWebhook($type, $data) {
    switch ($type) {
        case 'RECEIVE':
            handleReceive($data);
            break;
        case 'TRANSFER':
            handleTransfer($data);
            break;
        case 'CASHOUT':
            handleCashout($data);
            break;
        case 'REFUND':
            handleRefund($data);
            break;
        case 'INFRACTION':
            handleInfraction($data);
            break;
        default:
            error_log("Unknown webhook type: {$type}");
    }
}
?>
```
</CodeGroup>

## Webhook Testing

### Local Development with ngrok

<Steps>
<Step title="Install ngrok">
  Download and install ngrok from [ngrok.com](https://ngrok.com)
</Step>

<Step title="Start Your Server">
  Start your local webhook server on port 3000
</Step>

<Step title="Expose with ngrok">
  Run `ngrok http 3000` to get a public URL
</Step>

<Step title="Configure Webhook URL">
  Use the ngrok URL as your webhook URL in braix Dashboard
</Step>

<Step title="Test Webhooks">
  Create test payments to trigger webhooks
</Step>
</Steps>

### Webhook Testing Tools

<CardGroup cols={2}>
<Card title="Webhook.site" icon="globe" href="https://webhook.site">
  Test webhook endpoints with a temporary URL
</Card>

<Card title="RequestBin" icon="code" href="https://requestbin.com">
  Create temporary endpoints to inspect webhook payloads
</Card>

<Card title="ngrok" icon="terminal" href="https://ngrok.com">
  Expose local servers for webhook testing
</Card>

<Card title="Postman" icon="api" href="https://postman.com">
  Test webhook endpoints with mock requests
</Card>
</CardGroup>

## Webhook Retry Policy

braix implements the following retry policy for webhooks:

- **Initial attempt**: Immediate
- **Retry 1**: 1 minute after failure
- **Retry 2**: 5 minutes after failure
- **Retry 3**: 15 minutes after failure
- **Retry 4**: 1 hour after failure
- **Retry 5**: 6 hours after failure

<Warning>
Webhooks that fail after all retries are marked as failed and won't be retried again. Check your webhook delivery status regularly.
</Warning>

## Best Practices

### Webhook Endpoint Requirements

Your webhook endpoint must:

- Return HTTP 200 status for successful processing
- Respond within 30 seconds
- Handle duplicate deliveries gracefully
- Log all webhook events for debugging

<Check>
Webhook endpoints that consistently return non-200 status codes will be disabled automatically.
</Check>

### Error Handling

<AccordionGroup>
<Accordion title="Timeout Errors">
  - Ensure your webhook endpoint responds within 30 seconds
  - Implement async processing for long-running operations
  - Use proper HTTP status codes (200 for success)
</Accordion>

<Accordion title="Checksum Verification Failures">
  - Verify you're using the correct webhook secret
  - Ensure payload is not modified before verification
  - Check that checksum field is properly extracted
  - Compare with checksum from original transaction
</Accordion>

<Accordion title="Duplicate Webhooks">
  - Implement idempotency using the transaction ID
  - Store processed webhook IDs to prevent duplicates
  - Use database transactions for atomic operations
</Accordion>
</AccordionGroup>

### Monitoring and Alerting

<Steps>
<Step title="Set Up Monitoring">
  Monitor webhook delivery success rates and response times
</Step>

<Step title="Configure Alerts">
  Set up alerts for webhook failures and high error rates
</Step>

<Step title="Log Analysis">
  Implement comprehensive logging for webhook events
</Step>

<Step title="Health Checks">
  Regular health checks on your webhook endpoints
</Step>
</Steps>

## Troubleshooting

<AccordionGroup>
<Accordion title="Webhook Not Received">
  - Check if your endpoint is publicly accessible
  - Verify HTTPS is enabled (required for production)
  - Ensure your server is running and responding
  - Check firewall and network configuration
</Accordion>

<Accordion title="Checksum Verification Failing">
  - Verify webhook secret is correct
  - Check payload is not modified before verification
  - Ensure checksum field is properly extracted
  - Compare with checksum from original transaction
</Accordion>

<Accordion title="Duplicate Webhooks">
  - Implement idempotency using transaction ID
  - Store processed webhook IDs
  - Use database transactions for atomic operations
  - Handle retry scenarios gracefully
</Accordion>
</AccordionGroup>
